        -:    0:Source:chunk_manager.c
        -:    0:Graph:chunk_manager.gcno
        -:    0:Data:chunk_manager.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <sys/mman.h>
        -:    4:#include <sys/stat.h>
        -:    5:#include <stdlib.h>
        -:    6:#include <fcntl.h>
        -:    7:#include <sys/types.h>
        -:    8:#include <assert.h>
        -:    9:#include <unistd.h>
        -:   10:#include <errno.h>
        -:   11:#include <string.h>
        -:   12:
        -:   13:
        -:   14:enum State {
        -:   15:    EMPTY = 0,
        -:   16:    READY = 1,
        -:   17:    BUSY = 2
        -:   18:};
        -:   19:
        -:   20:struct Chunk {
        -:   21:    void* ptr;
        -:   22:    off_t offset;
        -:   23:    size_t size;
        -:   24:    size_t state;
        -:   25:    size_t refcount;
        -:   26:};
        -:   27:
        -:   28:struct Spool {
        -:   29:    unsigned char count;
        -:   30:    struct Chunk data[0];
        -:   31:};
        -:   32:
        -:   33:struct Pool {
        -:   34:    struct Spool** data;
        -:   35:
        -:   36:    unsigned char spool_size;
        -:   37:    int spool_count;
        -:   38:    int spool_max;
        -:   39:};
        -:   40:
        -:   41:
        -:   42:#define INIT_SPOOL_COUNT 1
        -:   43:
        1:   44:struct Pool* init_pool(){
        -:   45:
        1:   46:    size_t spool_size = 64;
        -:   47:
        -:   48:    if(sizeof(void*) == 4) {
        -:   49:        spool_size = 128;
        -:   50:    }
        -:   51:
        1:   52:    size_t size = spool_size * sizeof(struct Chunk) + sizeof(struct Spool) + sizeof(struct Pool);
        1:   53:    struct Pool* pool = (struct Pool*)calloc(1, size);
        1:   54:    if(!pool)
    #####:   55:        return (void*)-1;
        -:   56:
        -:   57:
        1:   58:    pool -> data = (struct Spool**)calloc(sizeof(void*), INIT_SPOOL_COUNT);
        1:   59:    if(!pool -> data) {
    #####:   60:        free(pool);
    #####:   61:        return (void*)-1;
        -:   62:    }
        -:   63:
        1:   64:    pool -> spool_size = spool_size;
        1:   65:    pool -> data[pool -> spool_count++] = (struct Spool*)((void*)pool + sizeof(struct Pool));
        1:   66:    pool -> spool_max = INIT_SPOOL_COUNT;
        -:   67:
        1:   68:    return pool;
        -:   69:}
        -:   70:
        1:   71:ssize_t destruct_pool(struct Pool* pool) {
        1:   72:    if(!pool)
    #####:   73:        return 0;
        -:   74:
        2:   75:    for(int i = 1; i < pool -> spool_count; i++)
        1:   76:        free(pool -> data[i]);
        -:   77:
        1:   78:    free(pool);
        -:   79:
        1:   80:    return 0;
        -:   81:}
        -:   82:
      161:   83:struct Chunk* allocate_chunk(struct Pool* pool, void* ptr, off_t offset, size_t size){
      161:   84:    if(!pool)
    #####:   85:        return 0;
        -:   86:
      194:   87:    for(int i = 0; i < pool -> spool_count; i++) {
        -:   88:
      193:   89:        if(pool -> data[i] -> count == pool -> spool_size)
       33:   90:            continue;
        -:   91:
      160:   92:        struct Chunk* tmp = pool -> data[i] -> data;
        -:   93:
     4432:   94:        for(int j = 0; j < pool -> spool_size; j++) {
     4432:   95:            if(tmp[j].state == EMPTY) {
      160:   96:                tmp[j].state = BUSY;
      160:   97:                tmp[j].refcount++;
        -:   98:
      160:   99:                tmp[j].ptr = ptr;
      160:  100:                tmp[j].offset = offset;
      160:  101:                tmp[j].size = size;
        -:  102:
      160:  103:                pool -> data[i] -> count++;
        -:  104:
      160:  105:                return &tmp[j];
        -:  106:            }
        -:  107:
        -:  108:        }
        -:  109:    }
        -:  110:
        -:  111:    //actions if all spools are full
        -:  112:
        1:  113:    void* free_candidate = 0;
        -:  114:
        1:  115:    if(pool -> spool_count == pool -> spool_max) {
        -:  116:
        1:  117:        struct Spool** tmp_data = (struct Spool**)calloc(pool->spool_max * 2, sizeof(void*));
        1:  118:        if(!tmp_data)
    #####:  119:            return 0;
        1:  120:        memcpy(tmp_data, pool -> data, sizeof(void*) * pool -> spool_count);
        -:  121:
        1:  122:        free_candidate = pool -> data;
        1:  123:        pool -> data = tmp_data;
        1:  124:        pool -> spool_max *= 2;
        -:  125:    }
        -:  126:
        1:  127:    size_t index = pool -> spool_count;
        1:  128:    struct Spool* tmp = (struct Spool*)calloc(1, sizeof(struct Spool) + sizeof(struct Chunk) * pool -> spool_size);
        1:  129:    if(!tmp)
    #####:  130:        return (void*)-1;
        -:  131:
        1:  132:    pool -> data[index] = tmp;
        1:  133:    pool -> spool_count++;
        -:  134:
        1:  135:    free(free_candidate); //Actually this can be a real problem if someone is handling previous pool -> data
        -:  136:
        1:  137:    return allocate_chunk(pool, ptr, offset, size);
        -:  138:}
        -:  139:
       80:  140:ssize_t deref_chunk(struct Pool* pool, struct Chunk* item) {
       80:  141:    if(!pool || !item)
    #####:  142:        return -1;
        -:  143:
       80:  144:    if(!item -> refcount) {
    #####:  145:        item -> refcount--;
    #####:  146:        return item -> refcount;
        -:  147:    }
        -:  148:
       96:  149:    for(int i = 0; i < pool -> spool_count; i++) {
       96:  150:        size_t bottom = (size_t)item - (size_t)(pool -> data[i] -> data);
       96:  151:        size_t top = (size_t)(pool -> data[i] -> data + pool -> spool_size) - (size_t)item;
        -:  152:
       96:  153:        if(bottom <= pool -> spool_size * sizeof(struct Chunk) && top <= pool -> spool_size * sizeof(struct Chunk)) {
       80:  154:            item -> state = BUSY;
       80:  155:            item -> refcount--;
        -:  156:
       80:  157:            pool -> data[i] -> count--;
       80:  158:            item -> state = EMPTY;
        -:  159:
       80:  160:            return 0;
        -:  161:        }
        -:  162:    }
        -:  163:
    #####:  164:    return -1;
        -:  165:}
        -:  166:
        1:  167:int main(){ //Such mini test, wow. Such works, so coverage
        1:  168:    struct Pool* pool = init_pool();
        -:  169:
        1:  170:    printf("Passed init \n");
        -:  171:
        1:  172:    struct Chunk* array[256] = {0};
       81:  173:    for(size_t i = 0; i < 80; i++) {
       80:  174:        array[i] = allocate_chunk(pool, (void*)i, i, i);
       80:  175:        if(array[i] == (void*)-1) {
    #####:  176:            printf("WTF \n");
    #####:  177:            exit(0);
        -:  178:        }
        -:  179:    }
        -:  180:
        1:  181:    printf("Passed allocation \n");
        -:  182:
       81:  183:    for(size_t i = 0; i < 80; i++) {
       80:  184:        deref_chunk(pool, array[i]);
        -:  185:    }
        -:  186:
        1:  187:    printf("Passed dereference \n");
        -:  188:
       81:  189:    for(size_t i = 0; i < 80; i++) {
       80:  190:        array[i] = allocate_chunk(pool, (void*)(i + 80), i + 80, i+ 80);
        -:  191:    }
        -:  192:
        1:  193:    printf("Passed 2nd allocation \n");
        -:  194:
        1:  195:    destruct_pool(pool);
        -:  196:}
