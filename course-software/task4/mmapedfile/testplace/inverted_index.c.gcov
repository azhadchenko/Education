        -:    0:Source:inverted_index.c
        -:    0:Graph:inverted_index.gcno
        -:    0:Data:inverted_index.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <sys/mman.h>
        -:    4:#include <sys/stat.h>
        -:    5:#include <stdlib.h>
        -:    6:#include <fcntl.h>
        -:    7:#include <sys/types.h>
        -:    8:#include <assert.h>
        -:    9:#include <unistd.h>
        -:   10:#include <errno.h>
        -:   11:#include <string.h>
        -:   12:
        -:   13:
        -:   14:enum State {
        -:   15:    EMPTY = 0,
        -:   16:    READY = 1,
        -:   17:    BUSY = 2
        -:   18:};
        -:   19:
        -:   20:struct Ii_element {
        -:   21:    void* item;
        -:   22:    size_t pos_inside;
        -:   23:    struct Ii_element* next;
        -:   24:    size_t state;
        -:   25:};
        -:   26:
        -:   27:struct Block {
        -:   28:    size_t count;
        -:   29:    struct Ii_element data[0];
        -:   30:};
        -:   31:
        -:   32:struct Ii_manager {
        -:   33:    struct Block** data;
        -:   34:
        -:   35:    unsigned char block_size;
        -:   36:    size_t block_count;
        -:   37:    size_t block_max;
        -:   38:};
        -:   39:
        -:   40:#define INIT_BLOCK_COUNT 2
        -:   41:
        1:   42:struct Ii_manager* init_ii_m(){
        -:   43:
        1:   44:    size_t block_size = 112;
        -:   45:
        -:   46:    if(sizeof(void*) == 4) {
        -:   47:        block_size = 224;
        -:   48:    }
        -:   49:
        1:   50:    size_t size = block_size * sizeof(struct Ii_element) + sizeof(struct Block) + sizeof(struct Ii_manager);
        1:   51:    struct Ii_manager* manager = (struct Ii_manager*)calloc(1, size);
        1:   52:    if(!manager)
    #####:   53:        return (void*)-1;
        -:   54:
        -:   55:
        1:   56:    manager -> data = (struct Block**)calloc(sizeof(void*), INIT_BLOCK_COUNT);
        1:   57:    if(!manager -> data) {
    #####:   58:        free(manager);
    #####:   59:        return (void*)-1;
        -:   60:    }
        -:   61:
        1:   62:    manager -> block_size = block_size;
        1:   63:    manager -> data[manager -> block_count++] = (struct Block*)((void*)manager + sizeof(struct Ii_manager));
        1:   64:    manager -> block_max = INIT_BLOCK_COUNT;
        -:   65:
        1:   66:    return manager;
        -:   67:}
        -:   68:
        1:   69:ssize_t destruct_ii_m(struct Ii_manager* manager) {
        1:   70:    if(!manager)
    #####:   71:        return 0;
        -:   72:
        8:   73:    for(int i = 1; i < manager -> block_count; i++)
        7:   74:        free(manager -> data[i]);
        -:   75:
        1:   76:    free(manager);
        -:   77:
        1:   78:    return 0;
        -:   79:}
        -:   80:
      903:   81:struct Ii_element* allocate_element(struct Ii_manager* manager, void* item, size_t pos_inside){
      903:   82:    if(!manager)
    #####:   83:        return 0;
        -:   84:
     4060:   85:    for(int i = 0; i < manager -> block_count; i++) {
        -:   86:
     4053:   87:        if(manager -> data[i] -> count == manager -> block_size)
     3157:   88:            continue;
        -:   89:
      896:   90:        struct Ii_element* tmp = manager -> data[i] -> data;
        -:   91:
    50513:   92:        for(int j = 0; j < manager -> block_size; j++) {
    50513:   93:            if(tmp[j].state == EMPTY) {
        -:   94:
      896:   95:                tmp[j].item = item;
      896:   96:                tmp[j].pos_inside = pos_inside;
        -:   97:
        -:   98:
      896:   99:                manager -> data[i] -> count++;
        -:  100:
      896:  101:                tmp[j].state = READY;
        -:  102:
      896:  103:                return &tmp[j];
        -:  104:            }
        -:  105:
        -:  106:        }
        -:  107:    }
        -:  108:
        -:  109:    //actions if all blocks are full
        -:  110:
        7:  111:    void* free_candidate = 0;
        -:  112:
        7:  113:    if(manager -> block_count == manager -> block_max) {
        -:  114:
        2:  115:        struct Block** tmp_data = (struct Block**)calloc(manager -> block_max * 2, sizeof(void*));
        2:  116:        if(!tmp_data)
    #####:  117:            return 0;
        2:  118:        memcpy(tmp_data, manager -> data, sizeof(void*) * manager -> block_count);
        -:  119:
        2:  120:        free_candidate = manager -> data;
        2:  121:        manager -> data = tmp_data;
        2:  122:        manager -> block_max *= 2;
        -:  123:    }
        -:  124:
        7:  125:    size_t index = manager -> block_count;
        7:  126:    struct Block* tmp = (struct Block*)calloc(1, sizeof(struct Block) + sizeof(struct Ii_element) * manager -> block_size);
        7:  127:    if(!tmp)
    #####:  128:        return (void*)-1;
        -:  129:
        7:  130:    manager -> data[index] = tmp;
        7:  131:    manager -> block_count++;
        -:  132:
        7:  133:    free(free_candidate); //Actually this can be a real problem if someone is handling previous manager -> data
        -:  134:
        7:  135:    return allocate_element(manager, item, pos_inside);
        -:  136:}
        -:  137:
        -:  138:
      100:  139:ssize_t destruct_element(struct Ii_manager* manager, struct Ii_element* item) {
      100:  140:    if(!manager || !item)
       99:  141:        return -1;
        -:  142:
        1:  143:    for(int i = 0; i < manager -> block_count; i++) {
        1:  144:        size_t bottom = (size_t)item - (size_t)(manager -> data[i] -> data);
        1:  145:        size_t top = (size_t)(manager -> data[i] -> data + manager -> block_size) - (size_t)item;
        -:  146:
        1:  147:        if(bottom <= manager -> block_size * sizeof(struct Ii_element) && top <= manager -> block_size * sizeof(struct Ii_element)) {
        1:  148:            manager -> data[i] -> count--;
        1:  149:            item -> state = EMPTY;
        -:  150:
        -:  151:
        1:  152:            return 0;
        -:  153:        }
        -:  154:    }
        -:  155:
    #####:  156:    return -1;
        -:  157:}
        -:  158:
        -:  159:struct Inverted_index {
        -:  160:    struct Ii_manager* manager;
        -:  161:    struct Ii_element* data[0];
        -:  162:};
        -:  163:
        1:  164:struct Inverted_index* init_ii(size_t size) {
        -:  165:
        1:  166:    size_t alloc_size = sizeof(void*) * size + sizeof(struct Inverted_index);
        -:  167:
        1:  168:    struct Inverted_index* ii = (struct Inverted_index*)calloc(1, alloc_size);
        1:  169:    if(!ii)
    #####:  170:        return (void*)-1;
        -:  171:
        1:  172:    ii -> manager = init_ii_m();
        1:  173:    if(ii -> manager == (void*)-1) {
    #####:  174:        free(ii);
    #####:  175:        return (void*)-1;
        -:  176:    }
        -:  177:
        1:  178:    return ii;
        -:  179:}
        -:  180:
        1:  181:ssize_t destruct_ii(struct Inverted_index* ii) {
        1:  182:    if(!ii)
    #####:  183:        return 0;
        -:  184:
        1:  185:    destruct_ii_m(ii -> manager);
        1:  186:    free(ii);
        -:  187:
        1:  188:    return 0;
        -:  189:}
        -:  190:
      256:  191:ssize_t add_item(struct Inverted_index* ii, void* item, size_t start, size_t until){
      256:  192:    if(!ii)
    #####:  193:        return -1;
        -:  194:
     1152:  195:    for(size_t i = start; i <= until; i++) {
        -:  196:
      896:  197:        struct Ii_element* tmp = allocate_element(ii -> manager, item, i - start);
      896:  198:        if(tmp == (void*)-1)
    #####:  199:            return i - start;
        -:  200:
      896:  201:        tmp -> next = 0;
        -:  202:
      896:  203:        struct Ii_element* place = ii -> data[i];
      896:  204:        if(!place) {
      256:  205:            ii -> data[i] = tmp;
      256:  206:            continue;
        -:  207:        }
        -:  208:
     2540:  209:        while(place -> next)
     1260:  210:            place = place -> next;
        -:  211:
      640:  212:        place -> next = tmp;
        -:  213:    }
        -:  214:
      256:  215:    return until - start;
        -:  216:}
        -:  217:
      100:  218:ssize_t delete_item(struct Inverted_index* ii, void* item, size_t start, size_t until) {
      100:  219:    if(!ii)
    #####:  220:        return 0;
        -:  221:
      200:  222:    for(size_t i = start; i <= until; i++) {
        -:  223:
      100:  224:        struct Ii_element* place = ii -> data[i];
      100:  225:        if(place -> item == item) {
        1:  226:            ii -> data[i] = place -> next;
        1:  227:            destruct_element(ii -> manager, place);
        -:  228:
        1:  229:            continue;
        -:  230:        }
        -:  231:
      584:  232:        while(place -> next && place -> next -> item != item)
      386:  233:            place = place -> next;
        -:  234:
       99:  235:        if(!place -> next)
    #####:  236:            return until - start;
        -:  237:
       99:  238:        place -> next = place -> next -> next;
       99:  239:        destruct_element(ii -> manager, place -> next);
        -:  240:
        -:  241:    }
        -:  242:
      100:  243:    return until - start;
        -:  244:}
        -:  245:
        -:  246:
        1:  247:int main(){
        1:  248:    struct Inverted_index* ii = init_ii(256);
        -:  249:
        1:  250:    printf("Init complete\n");
        1:  251:    fsync(STDOUT_FILENO);
        -:  252:
      129:  253:    for(size_t i = 0; i < 128; i++) {
      128:  254:        if(add_item(ii, (struct Ii_element*)i, i, i + 5) != 0)
        -:  255:            assert(5);
        -:  256:    }
        1:  257:    printf("Add complete\n");
        1:  258:    fsync(STDOUT_FILENO);
        -:  259:
        -:  260:
      101:  261:    for(size_t i = 0; i < 100; i++) {
      100:  262:        if(delete_item(ii, (struct Ii_element*)i, i, i) != 0)
    #####:  263:            assert(0);
        -:  264:    }
        -:  265:
        1:  266:    printf("Delete complete\n");
        1:  267:    fsync(STDOUT_FILENO);
        -:  268:
        -:  269:
      129:  270:    for(size_t i = 0; i < 128; i++) {
      128:  271:        if(add_item(ii, (struct Ii_element*)(i + 128), i + 128, i + 128) != 0)
    #####:  272:            assert(0);
        -:  273:    }
        -:  274:
        1:  275:    printf("Add2 complete\n");
        1:  276:    fsync(STDOUT_FILENO);
        -:  277:
        -:  278:
        1:  279:    assert(!destruct_ii(ii));
        -:  280:}
